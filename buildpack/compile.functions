# This file is part of heroku. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/heroku/master/COPYRIGHT. No part of heroku, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2015 The developers of heroku. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/heroku/master/COPYRIGHT.


core_usesIn heroku configure
heroku_buildpack_compile_initialise()
{
	heroku_configure_initialise
	heroku_buildpack_initialise
}

heroku_buildpack_compile_actionMessageAndNotes()
{
	local actionMessage="$1"
	shift 1
	printf '%s %s\n' '----->' "$actionMessage"
	
	if [ $# -ne 0 ]; then
		heroku_buildpack_compile_notesMessages "$@"
	fi
}

heroku_buildpack_compile_notesMessages()
{
	local noteMessage
	for noteMessage in "$@"
	do
		printf '       %s\n' "$noteMessage"
	done
}

heroku_buildpack_compile_guardStack()
{
	# The only environment variables (ie in 'env') we can rely on are STACK and SOURCE_VERSION
	heroku_buildpack_compile_actionMessageAndNotes "Validating environment variable STACK"
	
	if ! heroku_configure_validateStack "$STACK"; then
		core_exitError $core_commandLine_exitCode_CONFIG "Environment variable 'STACK' has unsupported value '$STACK'"
	fi
}

core_dependency_requires '*' mkdir
heroku_buildpack_compile_createCacheDirIfNotPresent()
{
	heroku_buildpack_compile_actionMessageAndNotes "Creating cache directory '$heroku_buildpack_cacheDir' if not present"
	
	mkdir -m 0755 -p "$heroku_buildpack_cacheDir"
	pushd "$heroku_buildpack_cacheDir"
		heroku_buildpack_cacheDir="$(pwd)"
	popd
}

# Sadly, this approach will 'lose' any trailing line feeds
heroku_buildpack_compile_getConfigurationVariableValue()
{
	local configurationVariableName="$1"
	
	heroku_buildpack_compile_notesMessages "Getting environment variable '$configurationVariableName'"
	
	local variableToSetName=heroku_configurationVariable_${configurationVariableName}
	local configurationVariableFilePath="$heroku_buildpack_envDir"/"$configurationVariableName"
	
	if [ ! -f "$configurationVariableFilePath" ]; then
		core_exitError $core_commandLine_exitCode_CONFIG "There is no environment variable '$configurationVariableName' at '$configurationVariableFilePath'"
	fi
	core_variable_setVariable "$variableToSetName" "$(<"$configurationVariableFilePath")"
}

heroku_buildpack_compile_sourceKnownCompileConfigurationVariables()
{
	heroku_buildpack_compile_actionMessageAndNotes "Sourcing known configuration variables"
}

heroku_buildpack_compile_sourceCompileExtensions()
{
	heroku_buildpack_compile_actionMessageAndNotes "Sourcing Compile extensions"
	
	local extensionsFolderPath="$heroku_compile_configurationFolderPath"/"$heroku_extensionsConfigurationFolderName"
	if ! core_path_isReadableAndSearchableFolderPath "$extensionsFolderPath"; then
		heroku_buildpack_compile_notesMessages "There are no extensions"
		return 0
	fi
	
	pushd "$extensionsFolderPath"
		
		local compileExtensionFile
		set +f
		for compileExtensionFile in *.compile.sh
		do
			set -f
			
			heroku_buildpack_compile_notesMessages "Sourcing compile extension '$compileExtensionFile'"
			
			# ./ required for source to work in some shells
			. ./"$compileExtensionFile"
		done
		set -f
	
	popd
}

_heroku_buildpack_compile_delegateToMultiBuildpack_processBuildpackUrl()
{
	local url="${buildpackUrl%#*}"
	local branch="${buildpackUrl#*#}"
	
	if [ -z "$url" ]; then
		return 0
	fi
	
	if [ "$url" = "$branch" ]; then
		branch=''
	fi
	
	local filename="$(core_compability_basename "$url")"
	local allFileExtensions="${filename#*.}"
	if [ ${#allFileExtensions} = ${#filename} ]; then
		allFileExtensions=''
	fi
	
	case "$allFileExtensions" in
		
		tar.gz|tgz)
			:
		;;
		
		git)
			# Need to use the cache dir if possible... but how do we name our asset in it?
			git clone "$url" "$SOME_DIR"
			if [ -n "$branch" ]; then
				pushd "$SOME_DIR"
					git checkout "$branch"
				popd
			fi
		;;
		
		*)
			heroku_buildpack_compile_notesMessages "Do not understand how to extract URLs like '$url' with file extension '$allFileExtensions' (from '$buildpackUrl')"
		;;
		
	esac
	# check the file extension, if .git, then treat as a git repo
}

core_dependency_requires '*' chmod
heroku_buildpack_compile_delegateToOtherBuildpacks()
{
	heroku_buildpack_compile_actionMessageAndNotes "Delegating to other buildpacks"
	
	_heroku_buildpack_compile_delegateToOtherBuildpacks_callback()
	{
		heroku_buildpack_compile_actionMessageAndNotes "Compiling buildpack '$buildpackFolderName'"
		
		heroku_buildpack_sourceFrameworkName true
		
		local compileFilePath="$buildpackBinFolderPath"/compile
		if ! core_path_isReadableNonEmptyFilePath "$compileFilePath"; then
			heroku_buildpack_compile_notesMessages "buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName' is missing 'compile'"
			return 0
		fi
		
		if ! core_path_isReadableNonEmptyExecutableFilePath "$compileFilePath"; then
			heroku_buildpack_compile_notesMessages "buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName' has 'compile' without execute bit set; continuing, but you should fix this"
			chmod +x "$compileFilePath"
		fi

		heroku_buildpack_compile_notesMessages "Compiling buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName'"
		set +e
		"$compileFilePath" "$heroku_buildpack_buildDir" "$heroku_buildpack_cacheDir" "$heroku_buildpack_envDir"
		local exitCode=$?
		set -e
		
		if [ $exitCode -ne 0 ]; then
			heroku_buildpack_compile_notesMessages "Compiling buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName' failed with exit code '$exitCode'"
			exit $core_commandLine_exitCode_FAILURE
		fi
		heroku_buildpack_compile_notesMessages "Compiled buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName'"
		
		heroku_buildpack_sourceEnvironment true
	}
	
	heroku_buildpack_iterateOverBuildpacksToDelegateTo _heroku_buildpack_compile_delegateToOtherBuildpacks_callback
		
	local buildpackUrl
	while IFS= read -r buildpackUrl
	do
		_heroku_buildpack_compile_delegateToMultiBuildpack_processBuildpackUrl
	done <"$heroku_buildpack_buildDir"/.buildpacks
	if [ -n "$buildpackUrl" ]; then
		_heroku_buildpack_compile_delegateToMultiBuildpack_processBuildpackUrl
	fi
	
	
	for BUILDPACK in $(cat $1/.buildpacks); do
	  dir=$(mktemp -t buildpackXXXXX)
	  rm -rf $dir

	  if [ "$url" != "" ]; then
	    echo "=====> Downloading Buildpack: $url"

	    if [[ "$url" =~ \.tgz$ ]] || [[ "$url" =~ \.tgz\? ]]; then
	      mkdir -p "$dir"
	      curl -s "$url" | tar xvz -C "$dir" >/dev/null 2>&1
	    else
	      git clone $url $dir >/dev/null 2>&1
	    fi
	    cd $dir

	    if [ "$branch" != "" ]; then
	      git checkout $branch >/dev/null 2>&1
	    fi

	    # we'll get errors later if these are needed and don't exist
	    chmod -f +x $dir/bin/{detect,compile,release} || true

	    framework=$($dir/bin/detect $1)

	    if [ $? == 0 ]; then
	      echo "=====> Detected Framework: $framework"
	      $dir/bin/compile $1 $2 $3

	      if [ $? != 0 ]; then
	        exit 1
	      fi

	      # check if the buildpack left behind an environment for subsequent ones
	      if [ -e $dir/export ]; then
	        source $dir/export
	      fi

	      if [ -x $dir/bin/release ]; then
	        $dir/bin/release $1 > $1/last_pack_release.out
	      fi
	    else
	      echo "Couldn't detect any framework for this buildpack. Exiting."
	      exit 1
	    fi
	  fi
	done

	if [ -e $1/last_pack_release.out ]; then
	  echo "Using release configuration from last framework ($framework)."
	fi
	
	
	
	
	
	
}
