# This file is part of shellfire heroku. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/shellfire-dev/heroku/master/COPYRIGHT. No part of shellfire heroku, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2015 The developers of shellfire heroku. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/shellfire-dev/heroku/master/COPYRIGHT.


core_usesIn heroku configure
heroku_buildpack_compile_initialise()
{
	heroku_configure_initialise
	heroku_buildpack_initialise
}

heroku_buildpack_compile_actionMessageAndNotes()
{
	local actionMessage="$1"
	shift 1
	printf '%s %s\n' '----->' "$actionMessage"
	
	if [ $# -ne 0 ]; then
		heroku_buildpack_compile_notesMessages "$@"
	fi
}

heroku_buildpack_compile_notesMessages()
{
	local noteMessage
	for noteMessage in "$@"
	do
		printf '       %s\n' "$noteMessage"
	done
}

heroku_buildpack_compile_guardStack()
{
	# The only environment variables (ie in 'env') we can rely on are STACK and SOURCE_VERSION
	heroku_buildpack_compile_actionMessageAndNotes "Validating environment variable STACK"
	
	if ! heroku_configure_validateStack "$STACK"; then
		core_exitError $core_commandLine_exitCode_CONFIG "Environment variable 'STACK' has unsupported value '$STACK'"
	fi
}

core_dependency_requires '*' mkdir
heroku_buildpack_compile_createCacheDirIfNotPresent()
{
	heroku_buildpack_compile_actionMessageAndNotes "Creating cache directory '$heroku_buildpack_cacheDir' if not present"
	
	mkdir -m 0755 -p "$heroku_buildpack_cacheDir"
	pushd "$heroku_buildpack_cacheDir"
		heroku_buildpack_cacheDir="$(pwd)"
	popd
}

core_dependency_requires '*' mkdir
heroku_buildpack_compile_createOurPrivateCacheDirIfNotPresent()
{	
	heroku_buildpack_compile_actionMessageAndNotes "Creating our private cache directory '$heroku_buildpack_cacheDir' if not present"
	
	heroku_buildpack_ourPrivateCacheDir="$heroku_buildpack_cacheDir"/"$heroku_frameworkName"
	mkdir -m 0755 -p "$heroku_buildpack_ourPrivateCacheDir"
}

# Sadly, this approach will 'lose' any trailing line feeds
heroku_buildpack_compile_getConfigurationVariableValue()
{
	local configurationVariableName="$1"
	
	heroku_buildpack_compile_notesMessages "Getting environment variable '$configurationVariableName'"
	
	local variableToSetName=heroku_configurationVariable_${configurationVariableName}
	local configurationVariableFilePath="$heroku_buildpack_envDir"/"$configurationVariableName"
	
	if [ ! -f "$configurationVariableFilePath" ]; then
		core_exitError $core_commandLine_exitCode_CONFIG "There is no environment variable '$configurationVariableName' at '$configurationVariableFilePath'"
	fi
	core_variable_setVariable "$variableToSetName" "$(<"$configurationVariableFilePath")"
}

heroku_buildpack_compile_sourceKnownCompileConfigurationVariables()
{
	heroku_buildpack_compile_actionMessageAndNotes "Sourcing known configuration variables"
}

core_usesIn git
heroku_buildpack_compile_installOrUpdateLinuxbrewInCacheForBuildDependencies()
{
	_heroku_buildpack_compile_linuxbrewFolderPath="$heroku_buildpack_ourPrivateCacheDir"/.linuxbrew
	
	if core_path_isReadableAndSearchableAndWritableFolderPath "$_heroku_buildpack_compile_linuxbrewFolderPath"/.git; then
		heroku_buildpack_compile_actionMessageAndNotes "Updating linuxbrew in cache (for build dependencies); may take some time"
		"$_heroku_buildpack_compile_linuxbrewFolderPath"/bin/brew update
		return 0
	else
		heroku_buildpack_compile_actionMessageAndNotes "Installing linuxbrew in cache (for build dependencies)"
		git clone --quiet "$heroku_linuxbrewRepositoryUrl" "$_heroku_buildpack_compile_linuxbrewFolderPath"
	fi
	
	heroku_buildpack_setLinuxbrewPathVariable PATH bin "$_heroku_buildpack_compile_linuxbrewFolderPath"
	heroku_buildpack_setLinuxbrewPathVariable MANPATH share/man "$_heroku_buildpack_compile_linuxbrewFolderPath"
	heroku_buildpack_setLinuxbrewPathVariable INFOPATH share/info "$_heroku_buildpack_compile_linuxbrewFolderPath"
	heroku_buildpack_setLinuxbrewPathVariable LD_LIBRARY_PATH lib "$_heroku_buildpack_compile_linuxbrewFolderPath"

}

core_dependency_requires '*' sort comm cat xargs
heroku_buildpack_compile_removeNoLongerUsedLinuxbrewBuildDependencies()
{
	heroku_buildpack_compile_actionMessageAndNotes "Removing no longer used linuxbrew dependencies" "Installing brew-rmtree if missing"
	brew tap beeftornado/rmtree 1>/dev/null 2>/dev/null
	brew install beeftornado/rmtree/brew-rmtree
echo HELLO	
	_heroku_buildpack_compile_dependenciesFileName="$heroku_compile_configurationFolderPath"/"$heroku_linuxbrewBuildDependenciesFileName"

	local TMP_FILE
	
	core_temporaryFiles_newFileToRemoveOnExit
	local sortedUniquePackagesWithoutTapsToInstallFilePath="$TMP_FILE"
	
	core_temporaryFiles_newFileToRemoveOnExit
	local sortedUniquePackagesWithoutTapsToRemoveFilePath="$TMP_FILE"
	
	core_temporaryFiles_newFileToRemoveOnExit
	local sortedUniquePackagesWithoutTapsToIgnoreFilePath="$TMP_FILE"

	{
		local packageToInstall
		while IFS= read -r packageToInstall
		do
			if [ -z "$packageToInstall" ]; then
				continue
			fi
			
			if core_variable_startsWith "$packageToInstall" '#'; then
				continue
			fi
			
			# Is package already installed?
			local package="$(core_compatibility_basename "$packageToInstall")"
			printf '%s' "$package"
		done <"$dependenciesFileName"
	} | sort -u >"$sortedUniquePackagesWithoutTapsToInstallFilePath"
	
	brew list -1 | comm -23 - "$sortedUniquePackagesWithoutTapsToInstallFilePath" >"$sortedUniquePackagesWithoutTapsToRemoveFilePath"
	
	local packagesToRemove
	local packagesToRemove_initialised
	core_variable_array_initialise
	
	local packageToRemove
	while IFS= read -r packageToRemove
	do
		core_variable_array_append packagesToRemove "$packageToRemove"
	done <"$sortedUniquePackagesWithoutTapsToRemoveFilePath"
	
	# do not try to ignore things not installed
	brew list -1 | comm -12 - "$sortedUniquePackagesWithoutTapsToRemoveFilePath" >"$sortedUniquePackagesWithoutTapsToIgnoreFilePath"
	
	_heroku_buildpack_compile_removeNoLongerUsedPackages_callback()
	{
		heroku_buildpack_compile_notesMessages "Removing unused linuxbrew build dependencies"
		if [ -s "$sortedUniquePackagesWithoutTapsToIgnoreFilePath" ]; then
			cat "$sortedUniquePackagesWithoutTapsToIgnoreFilePath" | xargs brew rmtree "$@" --ignore
		else
			 brew rmtree "$@"
		fi
	}
	
	core_variable_array_passToFunctionAsArguments packagesToRemove _heroku_buildpack_compile_removeNoLongerUsedPackages_callback
}

core_dependency_requires '*' grep
heroku_buildpack_compile_installLinuxbrewBuildDependencies()
{
	heroku_buildpack_compile_actionMessageAndNotes "Installing linuxbrew build dependencies"
	
	local packagesToInstall
	local packagesToInstall_initialised
	core_variable_array_initialise
	
	local packageToInstall
	while IFS= read -r packageToInstall
	do
		if [ -z "$packageToInstall" ]; then
			continue
		fi
		
		if core_variable_startsWith "$packageToInstall" '#'; then
			continue
		fi
		
		# Is package already installed?
		local package="$(core_compatibility_basename "$packageToInstall")"
		if brew list -1 | grep -q '^'"$package"'$'; then
			continue
		fi
		
		core_variable_array_appendUniquely packagesToInstall "$packageToInstall"
	done <"$_heroku_buildpack_compile_dependenciesFileName"
	
	core_variable_unset core_dependency_check_forcePackageManagerUpgradeDuringInstall
	core_variable_array_passToFunctionAsArguments packagesToInstall core_dependency_check_Homebrew_packageManager
}

heroku_buildpack_compile_sourceCompileExtensions()
{
	heroku_buildpack_compile_actionMessageAndNotes "Sourcing Compile extensions"
	
	local extensionsFolderPath="$heroku_compile_configurationFolderPath"/"$heroku_extensionsConfigurationFolderName"
	if ! core_path_isReadableAndSearchableFolderPath "$extensionsFolderPath"; then
		heroku_buildpack_compile_notesMessages "There are no extensions"
		return 0
	fi
	
	pushd "$extensionsFolderPath"
		
		local compileExtensionFile
		set +f
		for compileExtensionFile in *.compile.sh
		do
			set -f
			
			heroku_buildpack_compile_notesMessages "Sourcing compile extension '$compileExtensionFile'"
			
			# ./ required for source to work in some shells
			. ./"$compileExtensionFile"
		done
		set -f
	
	popd
}

core_dependency_requires '*' chmod
heroku_buildpack_compile_delegateToOtherBuildpacks()
{
	heroku_buildpack_compile_actionMessageAndNotes "Delegating to other buildpacks"
	
	_heroku_buildpack_compile_delegateToOtherBuildpacks_callback()
	{
		heroku_buildpack_compile_actionMessageAndNotes "Compiling buildpack '$buildpackFolderName'"
		
		heroku_buildpack_sourceFrameworkName true
		
		local compileFilePath="$buildpackBinFolderPath"/compile
		if ! core_path_isReadableNonEmptyFilePath "$compileFilePath"; then
			heroku_buildpack_compile_notesMessages "buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName' is missing 'compile'"
			return 0
		fi
		
		if ! core_path_isReadableNonEmptyExecutableFilePath "$compileFilePath"; then
			heroku_buildpack_compile_notesMessages "buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName' has 'compile' without execute bit set; continuing, but you should fix this"
			chmod +x "$compileFilePath"
		fi

		heroku_buildpack_compile_notesMessages "Running 'compile' for buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName'"
		set +e
		"$compileFilePath" "$heroku_buildpack_buildDir" "$heroku_buildpack_cacheDir" "$heroku_buildpack_envDir"
		local exitCode=$?
		set -e
		
		if [ $exitCode -ne 0 ]; then
			heroku_buildpack_compile_notesMessages "Run of 'compile' for buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName' failed with exit code '$exitCode'"
			exit $core_commandLine_exitCode_FAILURE
		fi
		heroku_buildpack_compile_notesMessages "Running 'compile' for buildpack '$buildpackFolderName' for framework '$heroku_buildpack_frameworkName' succeeded"
		
		heroku_buildpack_sourceEnvironment true
	}
	
	heroku_buildpack_iterateOverBuildpacksToDelegateTo _heroku_buildpack_compile_delegateToOtherBuildpacks_callback
}
