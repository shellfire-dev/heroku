# This file is part of heroku. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/heroku/master/COPYRIGHT. No part of heroku, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2015 The developers of heroku. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/heroku/master/COPYRIGHT.


heroku_configurationFolderName='.heroku.rc.d'
core_dependency_declares heroku_configurationFolderName

heroku_buildpacksConfigurationFolderName='buildpacks'
core_dependency_declares heroku_buildpacksConfigurationFolderName

heroku_environmentVariablesConfigurationFolderName='environment-variables'
core_dependency_declares heroku_buildpacksConfigurationFolderName

heroku_frameworkName='heroku-skeleton'
core_dependency_declares heroku_frameworkName

heroku_inRepository()
{
	pushd "$heroku_repositoryPath"
		
		set +e
		heroku "$@" 1>"$_heroku_standardOutputFilePath" 2>"$_heroku_errorOutputFilePath"
		local exitCode=$?
		set -e
		
	popd
	
	
	if [ $exitCode -ne 0 ]; then
		local warningLevel=FAIL
	else
		local warningLevel=INFO
	fi
	
	if [ -s "$_heroku_standardOutputFilePath" ]; then
		core_message "$warningLevel" "heroku: stdout: $(<"$_heroku_standardOutputFilePath")"
	fi
	
	if [ -s "$_heroku_errorOutputFilePath" ]; then
		core_message "$warningLevel" "heroku: stderr: $(<"$_heroku_errorOutputFilePath")"
	fi
	
	if [ $exitCode -ne 0 ]; then
		core_exitError $core_commandLine_exitCode_SOFTWARE "heroku '$@' failed with exit code '$exitCode'"
	fi
}

heroku_initialise()
{
	local TMP_FILE
	
	core_temporaryFiles_newFileToRemoveOnExit
	_heroku_standardOutputFilePath="$TMP_FILE"
	
	core_temporaryFiles_newFileToRemoveOnExit
	_heroku_errorOutputFilePath="$TMP_FILE"
}

core_dependency_requires '*' git cut
core_usesIn git
heroku_findBuildPackUrl()
{
	local submoduleName='.heroku.rc.d/heroku-skeleton-buildpack'
	
	local backpackUrl="$(git config --file "$heroku_repositoryPath"/.gitmodules --get "submodule.${submoduleName}.url")"
	local backpackRevision="$(git_inRepository "$heroku_repositoryPath" git submodule status "$submoduleName" | cut -c2-41)"
	
	heroku_buildpackUrl="${backpackUrl}#${backpackRevision}"
}

core_dependency_requires '*' heroku
heroku_createApp()
{
	if ! core_path_isReadableAndSearchableAndWritableFolderPath "$heroku_repositoryPath"/.git; then
		core_exitError $core_commandLine_exitCode_CANTCREAT "The .git folder in '$heroku_repositoryPath' is not writable; it needs to be when creating an app"
	fi
	
	heroku_inRepository create "$heroku_appName" --stack "$heroku_stack" --region "$heroku_region" --remote "$heroku_remote" --buildpack "$heroku_buildpackUrl"
	
	# We live in /app
	# The PATH defaults to /usr/local/bin:/usr/bin:/bin
	# /app contains our git repo, essentially, but less .git
	# /usr/local/bin is empty but owned by root so we can't install to it
	# We also have a .profile.d folder we can put scripts in, apparently
	# Our file system is writable (but transient)


	# We can run apt-get -d install, etc, and put them in our cache folder
	# But deb packages aren't designed to be relocatable, we'd need to chroot, for which we need to be root...
	# Other options:-
	#  Rootless GoboLinux  http://www.gobolinux.org/?page=rootless
	#  ArchLinux JuNest https://github.com/fsquillace/junest
	#  Install fakechroot manually?
	#  klik http://klik.atekon.de/ (Dead)
	#  AppImageKit  https://github.com/probonopd/AppImageKit
	#  apt-get source / dpkg -x (just does an extract)  https://serverfault.com/questions/23734/is-there-any-way-to-get-apt-to-install-packages-to-my-home-directory; this is what most solutions do, sadly.
	#  linuxbrew


	# Also examine
	# https://github.com/heroku/heroku-buildpack-multi (combine buildpacks)
	# https://github.com/peterkeen/heroku-buildpack-vendorbinaries (install from tarballs)
	# https://github.com/docverter/docverter

	# Personally, I'd like to move to a design where the heroku stuff is in a 'heroku' folder, but that requires a variant of the inline buildpack that doesn't look in 'bin'

	# I'd also like to be able to run the heroku toolbelt on heroku itself, or at least do basic deployment using shell script and not ruby + java

	# heroku run bash
}

core_usesIn git
heroku_createAppIfNecessary()
{
	if git_hasRemote "$heroku_repositoryPath" "$heroku_remote"; then
		
		# TODO: We only want to do these steps if things have changed...
		heroku_inRepository buildpacks:set "$heroku_buildpackUrl"
		
		# Can be avoided by parsing 1st line of heroko info | head -n 1 | cut -c4
		# except EPIPE results...
		heroku_inRepository apps:rename "$heroku_appName"
	else
		heroku_createApp	
	fi
}

core_dependency_requires '*' heroku
heroku_setEnvironmentVariables()
{
	# Not a perfect system, as there are other env variables that might not be in source control (for good reasons)
	# Designed to support, say, the Ant buildpack: https://github.com/dennisg/heroku-buildpack-ant
	# Strips any trailing line feeds, sadly
	
	heroku_environmentVariablesConfigurationFolderPath="$heroku_configurationFolderPath"/"$heroku_environmentVariablesConfigurationFolderName"

	if ! core_path_isReadableAndSearchableAndWritableFolderPath "$heroku_environmentVariablesConfigurationFolderPath"; then
		return 0
	fi
	
	local environmentVariables
	local environmentVariables_initialised
	core_variable_array_initialise environmentVariables
	
	pushd "$heroku_environmentVariablesConfigurationFolderPath"
		
		local environmentVariableFileName
		set +f
		for environmentVariableFile in *
		do
			set -f
			
			if ! core_path_isReadableFilePath "$environmentVariableFile"; then
				continue
			fi
			
			case "$environmentVariableFile" in
				
				.*)
					# Ignore .gitignore, etc files
					continue
				;;
				
			esac

			core_variable_array_append environmentVariables "$environmentVariableFileName"="$(<"$environmentVariableFile")"
			# We can unset any key, it needn't exist, but getting a list of keys without a silly message is hard
			
			
		done
		set -f
		
	popd
	
	_heroku_setEnvironmentVariables_callback()
	{
		heroku_inRepository config:set "$@"
	}
	
	core_variable_array_passToFunctionAsArguments environmentVariables _heroku_setEnvironmentVariables_callback
}

core_usesIn git
heroku_push()
{
	git_push "$heroku_repositoryPath" "$heroku_remote" "$heroku_refspec":master || core_exitError $core_commandLine_exitCode_PROTOCOL "Deployment failure"
}
