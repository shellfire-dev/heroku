# This file is part of heroku. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/heroku/master/COPYRIGHT. No part of heroku, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2015 The developers of heroku. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/heroku/master/COPYRIGHT.


heroku_configurationFolderName='.heroku.rc.d'
core_dependency_declares heroku_configurationFolderName

heroku_buildpacksConfigurationFolderName='buildpacks'
core_dependency_declares heroku_buildpacksConfigurationFolderName

heroku_environmentVariablesConfigurationFolderName='environment-variables'
core_dependency_declares heroku_buildpacksConfigurationFolderName

heroku_frameworkName='heroku-skeleton'
core_dependency_declares heroku_frameworkName

heroku_initialise()
{
	local TMP_FILE
	
	core_temporaryFiles_newFileToRemoveOnExit
	_heroku_standardOutputFilePath="$TMP_FILE"
	
	core_temporaryFiles_newFileToRemoveOnExit
	_heroku_standardErrorFilePath="$TMP_FILE"
}

_heroku_inRepository_printLine()
{
	local message
	if $afterFirst; then
		message="> $line"
	else
		message="$line"
	fi
	core_message "$warningLevel" "heroku: $fileDescriptor: $message"
}

_heroku_inRepository_printLinesIfAny()
{
	local warningLevel="$1"
	local fileDescriptor="$2"
	local linesFilePath="$3"
	
	if [ ! -s "$linesFilePath" ]; then
		return 0
	fi
	
	local afterFirst=false
	local line
	while IFS= read -r line
	do
		_heroku_inRepository_printLine
		afterFirst=true
	done <"$linesFilePath"
	# Read any final line not terminated by '\n'; too bad
	if [ -n line ]; then
		_heroku_inRepository_printLine
		afterFirst=true
	fi
}

heroku_inRepository()
{
	local printStandardOut="$1"
	
	pushd "$heroku_repositoryPath"
		
		set +e
		heroku "$@" 1>"$_heroku_standardOutputFilePath" 2>"$_heroku_standardErrorFilePath"
		local exitCode=$?
		set -e
		
	popd
	
	local warningLevel
	if [ $exitCode -ne 0 ]; then
		warningLevel=WARN
	else
		warningLevel=INFO
	fi
	
	if $printStandardOut; then
		_heroku_inRepository_printLinesIfAny "$warningLevel" 'stdout' "$_heroku_standardOutputFilePath"
	fi
	_heroku_inRepository_printLinesIfAny "$warningLevel" 'stderr' "$_heroku_standardErrorFilePath"
		
	if [ $exitCode -ne 0 ]; then
		core_exitError $core_commandLine_exitCode_SOFTWARE "heroku '$@' failed with exit code '$exitCode'"
	fi
}

core_dependency_requires '*' git cut
core_usesIn git
heroku_findBuildPackUrl()
{
	local submoduleName='.heroku.rc.d/heroku-skeleton-buildpack'
	
	local backpackUrl="$(git config --file "$heroku_repositoryPath"/.gitmodules --get "submodule.${submoduleName}.url")"
	local backpackRevision="$(git_inRepository "$heroku_repositoryPath" git submodule status "$submoduleName" | cut -c2-41)"
	
	heroku_buildpackUrl="${backpackUrl}#${backpackRevision}"
}

core_dependency_requires '*' heroku
heroku_createApp()
{
	if ! core_path_isReadableAndSearchableAndWritableFolderPath "$heroku_repositoryPath"/.git; then
		core_exitError $core_commandLine_exitCode_CANTCREAT "The .git folder in '$heroku_repositoryPath' is not writable; it needs to be when creating an app"
	fi
	
	heroku_inRepository true create "$heroku_appName" --stack "$heroku_stack" --region "$heroku_region" --remote "$heroku_remote" --buildpack "$heroku_buildpackUrl"
	
	# We live in /app
	# The PATH defaults to /usr/local/bin:/usr/bin:/bin
	# /app contains our git repo, essentially, but less .git
	# /usr/local/bin is empty but owned by root so we can't install to it
	# We also have a .profile.d folder we can put scripts in, apparently
	# Our file system is writable (but transient)


	# We can run apt-get -d install, etc, and put them in our cache folder
	# But deb packages aren't designed to be relocatable, we'd need to chroot, for which we need to be root...
	# Other options:-
	#  Rootless GoboLinux  http://www.gobolinux.org/?page=rootless
	#  ArchLinux JuNest https://github.com/fsquillace/junest
	#  Install fakechroot manually?
	#  klik http://klik.atekon.de/ (Dead)
	#  AppImageKit  https://github.com/probonopd/AppImageKit
	#  apt-get source / dpkg -x (just does an extract)  https://serverfault.com/questions/23734/is-there-any-way-to-get-apt-to-install-packages-to-my-home-directory; this is what most solutions do, sadly.
	#  linuxbrew


	# Also examine
	# https://github.com/heroku/heroku-buildpack-multi (combine buildpacks)
	# https://github.com/peterkeen/heroku-buildpack-vendorbinaries (install from tarballs)
	# https://github.com/docverter/docverter

	# Personally, I'd like to move to a design where the heroku stuff is in a 'heroku' folder, but that requires a variant of the inline buildpack that doesn't look in 'bin'

	# I'd also like to be able to run the heroku toolbelt on heroku itself, or at least do basic deployment using shell script and not ruby + java

	# heroku run bash
}

core_usesIn git
heroku_createAppIfNecessary()
{
	if git_hasRemote "$heroku_repositoryPath" "$heroku_remote"; then
		
		heroku_changeBuildpackUrlIfDifferent
		heroku_changeAppNameIfDifferent
		
	else
		heroku_createApp	
	fi
}

core_dependency_requires '*' tail head
heroku_changeBuildpackUrlIfDifferent()
{
	heroku_inRepository false buildpacks
	local existingBuildpackUrl="$(tail -n +2 "$_heroku_standardOutputFilePath" | head -n 1)"
	
	if [ "$existingBuildpackUrl" != "$heroku_buildpackUrl" ]; then
		heroku_inRepository true buildpacks:set "$heroku_buildpackUrl"
	fi
}

core_dependency_requires '*' head cut
heroku_changeAppNameIfDifferent()
{
	heroku_inRepository false info
	local existingAppName="$(head -n 1 "$_heroku_standardOutputFilePath" | cut -c5-)"
	
	if [ "$existingAppName" != "$heroku_appName" ]; then
		heroku_inRepository true apps:rename "$heroku_appName"
	fi
}

heroku_setEnvironmentVariables()
{
	# Not a perfect system, as there are other env variables that might not be in source control (for good reasons)
	# Designed to support, say, the Ant buildpack: https://github.com/dennisg/heroku-buildpack-ant
	# Strips any trailing line feeds, sadly
	
	heroku_environmentVariablesConfigurationFolderPath="$heroku_configurationFolderPath"/"$heroku_environmentVariablesConfigurationFolderName"

	if ! core_path_isReadableAndSearchableAndWritableFolderPath "$heroku_environmentVariablesConfigurationFolderPath"; then
		return 0
	fi
	
	local environmentVariables
	local environmentVariables_initialised
	core_variable_array_initialise environmentVariables
	
	pushd "$heroku_environmentVariablesConfigurationFolderPath"
		
		local environmentVariableFileName
		set +f
		for environmentVariableFile in *
		do
			set -f
			
			if ! core_path_isReadableFilePath "$environmentVariableFile"; then
				continue
			fi
			
			case "$environmentVariableFile" in
				
				.*)
					# Ignore .gitignore, etc files
					continue
				;;
				
			esac

			core_variable_array_append environmentVariables "$environmentVariableFileName"="$(<"$environmentVariableFile")"
			# We can unset any key, it needn't exist, but getting a list of keys without a silly message is hard
			
			
		done
		set -f
		
	popd
	
	_heroku_setEnvironmentVariables_callback()
	{
		if [ $# -eq 0 ]; then
			return 0
		fi
		heroku_inRepository true config:set "$@"
	}

	core_variable_array_passToFunctionAsArguments environmentVariables _heroku_setEnvironmentVariables_callback
}

core_usesIn git
heroku_push()
{
	git_push "$heroku_repositoryPath" "$heroku_remote" "$heroku_refspec":master || core_exitError $core_commandLine_exitCode_PROTOCOL "Deployment failure"
}
